{
  "name": "ATC Email Classification Pipeline v2 (Batch)",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes",
              "minutesInterval": 5
            }
          ]
        }
      },
      "id": "trigger-schedule",
      "name": "Every 5 Minutes",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [-3200, 0]
    },
    {
      "parameters": {
        "jsCode": "// ══════════════════════════════════════════════════\n// CONFIGURACIÓN DEL WORKFLOW v2 (Batch)\n// Edita la URL aquí. Credenciales se gestionan\n// desde Credentials en n8n (cifrados).\n// ══════════════════════════════════════════════════\nreturn [{\n  json: {\n    DREAMLAND_APP_URL: 'https://dreamland-app-theta.vercel.app'\n  }\n}];"
      },
      "id": "set-config",
      "name": "Set Config",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-2960, 0]
    },
    {
      "parameters": {
        "authentication": "serviceAccount",
        "operation": "getAll",
        "limit": 50,
        "simple": false,
        "filters": {
          "includeSpamTrash": false,
          "q": "is:unread"
        },
        "options": {}
      },
      "id": "gmail-get-unread",
      "name": "Gmail - Get Unread",
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [-2720, 0],
      "credentials": {
        "googleApi": {
          "id": "XyV4OgnMNyZQQ75y",
          "name": "Voltereta Service Account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const results = [];\n\nfor (const item of $input.all()) {\n  const msg = item.json;\n\n  const gmailId = msg.id || '';\n  const threadId = msg.threadId || '';\n  const messageId = msg.messageId || '';\n  const subject = msg.subject || '';\n  const date = msg.date || '';\n\n  const fromValue = msg.from?.value?.[0] || {};\n  const replyToValue = msg.replyTo?.value?.[0];\n\n  let fromEmail = fromValue.address || '';\n  let fromName = fromValue.name || '';\n\n  if (replyToValue && /^no[-.]?reply@/i.test(fromEmail)) {\n    fromEmail = replyToValue.address || fromEmail;\n    fromName = replyToValue.name || fromName;\n  }\n\n  let body = msg.text || '';\n  if (!body && msg.html) {\n    body = msg.html\n      .replace(/<style[^>]*>[\\s\\S]*?<\\/style>/gi, '')\n      .replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, '')\n      .replace(/<[^>]+>/g, ' ')\n      .replace(/&nbsp;/g, ' ').replace(/&amp;/g, '&')\n      .replace(/&lt;/g, '<').replace(/&gt;/g, '>')\n      .replace(/&quot;/g, '\"').replace(/&#\\d+;/g, '')\n      .replace(/\\s+/g, ' ').trim();\n  }\n\n  if (body.length > 3000) body = body.substring(0, 3000) + '...[truncado]';\n\n  results.push({\n    json: { gmailId, messageId, threadId, fromEmail, fromName, subject, date, body }\n  });\n}\n\nreturn results;"
      },
      "id": "extract-email-data",
      "name": "Extract Email Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-2480, 0]
    },
    {
      "parameters": {
        "jsCode": "// Agrupa todos los emails en 1 item para la llamada batch de dedup\nconst items = $input.all();\nif (items.length === 0) {\n  return [{ json: { messageIds: [], emails: [] } }];\n}\nreturn [{\n  json: {\n    messageIds: items.map(i => i.json.messageId),\n    emails: items.map(i => i.json)\n  }\n}];"
      },
      "id": "collect-message-ids",
      "name": "Collect MessageIds",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-2240, 0]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $('Set Config').first().json.DREAMLAND_APP_URL }}/api/atc/email/check-exists-batch",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ messageIds: $json.messageIds }) }}",
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          },
          "timeout": 15000
        }
      },
      "id": "batch-check-exists",
      "name": "Batch Check-Exists",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [-2000, 0],
      "onError": "continueRegularOutput",
      "credentials": {
        "httpHeaderAuth": {
          "id": "zhLT7GI5DSwc3rAG",
          "name": "Dreamland Header Auth"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Filtra emails que ya existen en la DB\n// Si check-exists fallo, existing sera undefined → Set vacio → todos pasan\nconst checkResult = $input.first().json;\nconst existingSet = new Set(checkResult.existing || []);\nconst allEmails = $('Collect MessageIds').first().json.emails;\n\nconst newEmails = allEmails.filter(email => !existingSet.has(email.messageId));\n\nreturn [{\n  json: {\n    noNewEmails: newEmails.length === 0,\n    emails: newEmails,\n    totalNew: newEmails.length,\n    totalSkipped: allEmails.length - newEmails.length\n  }\n}];"
      },
      "id": "filter-new-emails",
      "name": "Filter New Emails",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-1760, 0]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose"
          },
          "conditions": [
            {
              "id": "condition-has-new",
              "leftValue": "={{ $json.noNewEmails }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "notEquals",
                "singleValue": false
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "has-new-emails",
      "name": "Has New Emails?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [-1520, 0]
    },
    {
      "parameters": {
        "jsCode": "// Divide emails nuevos en lotes de 5 para clasificacion LLM batch\nconst emails = $input.first().json.emails;\nconst BATCH_SIZE = 5;\nconst batches = [];\n\nfor (let i = 0; i < emails.length; i += BATCH_SIZE) {\n  batches.push({\n    json: {\n      batchIndex: Math.floor(i / BATCH_SIZE),\n      emails: emails.slice(i, i + BATCH_SIZE)\n    }\n  });\n}\n\nreturn batches;"
      },
      "id": "prepare-batches",
      "name": "Prepare Batches",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-1200, -200]
    },
    {
      "parameters": {
        "jsCode": "// Construye el prompt multi-email y el body completo para OpenRouter\n// Incluye fecha actual para que el LLM resuelva fechas relativas\nconst items = $input.all();\nconst results = [];\nconst todayISO = new Date().toISOString().split('T')[0];\n\nfor (const item of items) {\n  const emails = item.json.emails;\n\n  // Bloques de email para el prompt\n  const emailBlocks = emails.map((email, i) => {\n    const body = email.body.length > 1500\n      ? email.body.substring(0, 1500) + '...[truncado]'\n      : email.body;\n    return '--- EMAIL #' + (i + 1) + ' ---\\n' +\n      'Message-ID: ' + email.messageId + '\\n' +\n      'De: ' + (email.fromName || '') + ' <' + email.fromEmail + '>\\n' +\n      'Asunto: ' + email.subject + '\\n\\n' +\n      body + '\\n' +\n      '--- FIN EMAIL #' + (i + 1) + ' ---';\n  }).join('\\n\\n');\n\n  // System prompt con categorias, prioridad base y extraccion de targetDate\n  const systemPrompt =\n    'Eres un clasificador de emails para el departamento de ATC de un grupo de restaurantes de alta gama (Dreamland).\\n' +\n    'HOY ES: ' + todayISO + '. Usa esta fecha para resolver referencias relativas (manana, el viernes, la proxima semana, etc.).\\n\\n' +\n    'Analiza TODOS los emails proporcionados y devuelve un JSON con la clasificacion de cada uno.\\n\\n' +\n    'CATEGORIAS (usa el slug mas especifico posible):\\n\\n' +\n    'Subcategorias (preferentes):\\n' +\n    '- reservas_nueva: solicitud de nueva reserva\\n' +\n    '- reservas_modificacion: cambio en reserva existente (fecha, hora, personas)\\n' +\n    '- reservas_cancelacion: cancelacion de reserva\\n' +\n    '- reservas_confirmacion: confirmacion de asistencia\\n' +\n    '- reclamaciones_servicio: queja sobre atencion o trato del personal\\n' +\n    '- reclamaciones_comida: queja sobre calidad, sabor o presentacion\\n' +\n    '- reclamaciones_cobro: error de cobro, cuenta incorrecta, cobro duplicado\\n' +\n    '- consultas_horarios: preguntas sobre horarios y disponibilidad\\n' +\n    '- consultas_menu: preguntas sobre carta, platos, opciones\\n' +\n    '- consultas_servicios: parking, terraza, wifi, accesibilidad\\n' +\n    '- facturacion_solicitud: solicitud de factura con datos fiscales\\n' +\n    '- facturacion_error: factura incorrecta o con datos erroneos\\n\\n' +\n    'Categorias generales (si ninguna subcategoria aplica):\\n' +\n    '- reservas, reclamaciones, consultas, facturacion\\n' +\n    '- eventos: evento privado, celebracion, grupo grande\\n' +\n    '- alergias: alergenos, intolerancias, dietas especiales\\n' +\n    '- objetos_perdidos: objeto olvidado en el local\\n' +\n    '- colaboraciones: propuesta comercial, proveedor, influencer\\n' +\n    '- empleo: CV, solicitud de empleo\\n' +\n    '- bonos: bono regalo, tarjeta regalo\\n' +\n    '- spam: publicidad, newsletter, email automatico irrelevante\\n' +\n    '- otro: no encaja en ninguna categoria\\n\\n' +\n    'PRIORIDAD BASE (solo por tipo de peticion, SIN considerar urgencia temporal):\\n' +\n    '- 5: URGENTE - queja grave, incidente salud/alergia, amenaza legal, VIP\\n' +\n    '- 4: ALTA - reclamacion formal, error cobro, cancelacion con reembolso, grupo >10\\n' +\n    '- 3: MEDIA - reserva nueva, modificacion, solicitud de factura, evento\\n' +\n    '- 2: BAJA - consulta general, horarios, informacion\\n' +\n    '- 1: MINIMA - spam, newsletters, empleo no solicitado\\n\\n' +\n    'VIP (sube +1 la prioridad base): email corporativo, grupo >10, evento corporativo, cliente frecuente.\\n\\n' +\n    'targetDate: la fecha que el cliente necesita gestionar (fecha de la reserva, evento, cancelacion, cita, etc.).\\n' +\n    'Resuelve fechas relativas como \"manana\", \"el viernes\", \"la proxima semana\" usando la fecha actual (' + todayISO + ').\\n' +\n    'Si el email no menciona ninguna fecha concreta o relevante, devuelve null.\\n' +\n    'Formato: YYYY-MM-DD o null.\\n\\n' +\n    'RESPONDE UNICAMENTE con un JSON valido con esta estructura exacta:\\n' +\n    '{ \"classifications\": [{ \"messageId\": \"<Message-ID>\", \"category\": \"<slug>\", \"label\": \"<max 25 chars>\", \"priority\": <1-5>, \"confidence\": <0.0-1.0>, \"summary\": \"<max 100 chars>\", \"targetDate\": \"YYYY-MM-DD o null\" }] }\\n\\n' +\n    'El array \"classifications\" debe tener EXACTAMENTE ' + emails.length + ' objetos, uno por email, en el MISMO orden.';\n\n  const llmBody = JSON.stringify({\n    model: 'openai/gpt-4o-mini',\n    temperature: 0.1,\n    response_format: { type: 'json_object' },\n    max_tokens: 6000,\n    messages: [\n      { role: 'system', content: systemPrompt },\n      { role: 'user', content: 'Clasifica estos ' + emails.length + ' emails:\\n\\n' + emailBlocks }\n    ]\n  });\n\n  results.push({ json: { llmBody, emails } });\n}\n\nreturn results;"
      },
      "id": "build-llm-prompt",
      "name": "Build LLM Prompt",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-960, -200]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://openrouter.ai/api/v1/chat/completions",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "HTTP-Referer",
              "value": "={{ $('Set Config').first().json.DREAMLAND_APP_URL }}"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.llmBody }}",
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          },
          "timeout": 60000
        }
      },
      "id": "classify-batch-llm",
      "name": "Classify Batch LLM",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [-720, -200],
      "credentials": {
        "httpHeaderAuth": {
          "id": "dmN4i6OWOCnL2ahf",
          "name": "OpenRouter Header Auth"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Parsea respuestas LLM, aplica ajuste temporal de prioridad y fusiona con datos originales\nconst llmResponses = $input.all();\nconst batchData = $('Build LLM Prompt').all();\nconst results = [];\n\n// Fecha de hoy a medianoche para calculo de dias\nconst today = new Date();\ntoday.setHours(0, 0, 0, 0);\n\nfor (let i = 0; i < llmResponses.length; i++) {\n  const llmResponse = llmResponses[i].json;\n  const batchEmails = batchData[i]?.json?.emails || [];\n  if (batchEmails.length === 0) continue;\n\n  let classifications = [];\n\n  try {\n    // Detectar si la respuesta del LLM es valida\n    const content = llmResponse.choices?.[0]?.message?.content;\n\n    if (!content) {\n      console.error('[Parse & Merge] Batch ' + i + ' - LLM response missing content:', JSON.stringify(llmResponse).substring(0, 500));\n      throw new Error('LLM response missing content');\n    }\n\n    // Log del raw content para debugging\n    console.log('[Parse & Merge] Batch ' + i + ' raw (' + content.length + ' chars): ' + content.substring(0, 300));\n\n    let parsed = JSON.parse(content);\n\n    if (!Array.isArray(parsed)) {\n      // Estrategia 1: buscar key conocida\n      if (parsed.classifications && Array.isArray(parsed.classifications)) {\n        parsed = parsed.classifications;\n      } else {\n        // Estrategia 2: buscar el primer valor que sea un array en el objeto\n        const arrayProp = Object.values(parsed).find(v => Array.isArray(v));\n        if (arrayProp) {\n          console.log('[Parse & Merge] Array found under non-standard key. Keys: ' + Object.keys(parsed).join(', '));\n          parsed = arrayProp;\n        } else if (parsed.messageId) {\n          // Estrategia 3: clasificacion individual\n          console.log('[Parse & Merge] Single classification object detected');\n          parsed = [parsed];\n        } else {\n          console.error('[Parse & Merge] No array found in response. Keys: ' + Object.keys(parsed).join(', '));\n          throw new Error('No classification array found in LLM response');\n        }\n      }\n    }\n\n    classifications = parsed.filter(item => item && typeof item === 'object');\n  } catch (e) {\n    console.error('[Parse & Merge] Error for batch ' + i + ':', e.message || e);\n    classifications = batchEmails.map(email => ({\n      messageId: email.messageId,\n      category: 'otro',\n      label: 'Error clasificacion',\n      priority: 3,\n      confidence: 0,\n      summary: 'Error: ' + (e.message || 'unknown').substring(0, 80),\n      targetDate: null\n    }));\n  }\n\n  const classMap = new Map();\n  for (const cls of classifications) {\n    if (cls.messageId) classMap.set(cls.messageId, cls);\n  }\n\n  for (let j = 0; j < batchEmails.length; j++) {\n    const email = batchEmails[j];\n    const cls = classMap.get(email.messageId) || classifications[j] || {};\n\n    // Extraer y validar targetDate del LLM\n    let targetDateISO = null;\n    const rawTarget = cls.targetDate || null;\n    if (rawTarget && rawTarget !== 'null') {\n      const parsedDate = new Date(rawTarget + 'T12:00:00');\n      if (!isNaN(parsedDate.getTime())) {\n        targetDateISO = parsedDate.toISOString().split('T')[0];\n      }\n    }\n\n    // Calcular modificador temporal\n    let temporalMod = 0;\n    if (targetDateISO) {\n      const target = new Date(targetDateISO + 'T12:00:00');\n      const daysUntil = Math.round((target - today) / 86400000);\n      if (daysUntil <= 1) temporalMod = 2;\n      else if (daysUntil <= 3) temporalMod = 1;\n      else if (daysUntil > 30) temporalMod = -1;\n    }\n\n    // Prioridad final = base (tipo) + modificador temporal, clamped 1-5\n    const basePriority = Math.min(Math.max(Math.round(cls.priority || 3), 1), 5);\n    const finalPriority = Math.min(Math.max(basePriority + temporalMod, 1), 5);\n\n    results.push({\n      json: {\n        messageId: email.messageId,\n        gmailId: email.gmailId,\n        threadId: email.threadId,\n        fromEmail: email.fromEmail,\n        fromName: email.fromName,\n        subject: email.subject,\n        body: email.body,\n        receivedAt: email.date ? new Date(email.date).toISOString() : new Date().toISOString(),\n        category: cls.category || 'otro',\n        aiLabel: (cls.label || 'Sin clasificar').substring(0, 25),\n        aiPriority: finalPriority,\n        aiConfidenceScore: Math.min(Math.max(cls.confidence || 0, 0), 1),\n        aiSummary: (cls.summary || '').substring(0, 100),\n        targetDate: targetDateISO\n      }\n    });\n  }\n}\n\nreturn results;"
      },
      "id": "parse-and-merge",
      "name": "Parse & Merge",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-480, -200]
    },
    {
      "parameters": {
        "jsCode": "// Recoge todos los emails clasificados y prepara payload batch para ingest\nconst items = $input.all();\nconst classifiedEmails = [];\nconst gmailIds = [];\n\nfor (const item of items) {\n  const d = item.json;\n  classifiedEmails.push({\n    messageId: d.messageId,\n    threadId: d.threadId,\n    fromEmail: d.fromEmail,\n    fromName: d.fromName,\n    subject: d.subject,\n    body: d.body,\n    receivedAt: d.receivedAt,\n    category: d.category,\n    aiLabel: d.aiLabel,\n    aiPriority: d.aiPriority,\n    aiConfidenceScore: d.aiConfidenceScore,\n    aiSummary: d.aiSummary,\n    targetDate: d.targetDate || null\n  });\n  gmailIds.push(d.gmailId);\n}\n\nreturn [{\n  json: {\n    classifiedEmails,\n    gmailIds,\n    totalCount: classifiedEmails.length\n  }\n}];"
      },
      "id": "collect-all-classified",
      "name": "Collect All Classified",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-240, -200]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $('Set Config').first().json.DREAMLAND_APP_URL }}/api/atc/email/ingest",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.classifiedEmails) }}",
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          },
          "timeout": 30000
        }
      },
      "id": "batch-ingest",
      "name": "Batch Ingest",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [0, -200],
      "credentials": {
        "httpHeaderAuth": {
          "id": "zhLT7GI5DSwc3rAG",
          "name": "Dreamland Header Auth"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Prepara 1 item por email para marcar como leido en Gmail\nconst gmailIds = $('Collect All Classified').first().json.gmailIds;\nreturn gmailIds.map(id => ({ json: { gmailId: id } }));"
      },
      "id": "prepare-mark-read",
      "name": "Prepare Mark Read",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [240, -200],
      "disabled": true
    },
    {
      "parameters": {
        "authentication": "serviceAccount",
        "operation": "markAsRead",
        "messageId": "={{ $json.gmailId }}"
      },
      "id": "gmail-mark-read",
      "name": "Gmail - Mark as Read",
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [480, -200],
      "disabled": true,
      "credentials": {
        "googleApi": {
          "id": "XyV4OgnMNyZQQ75y",
          "name": "Voltereta Service Account"
        }
      }
    },
    {
      "parameters": {},
      "id": "all-duplicates",
      "name": "All Duplicates",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [-1200, 200]
    }
  ],
  "connections": {
    "Every 5 Minutes": {
      "main": [
        [
          {
            "node": "Set Config",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Config": {
      "main": [
        [
          {
            "node": "Gmail - Get Unread",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Gmail - Get Unread": {
      "main": [
        [
          {
            "node": "Extract Email Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Email Data": {
      "main": [
        [
          {
            "node": "Collect MessageIds",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Collect MessageIds": {
      "main": [
        [
          {
            "node": "Batch Check-Exists",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Batch Check-Exists": {
      "main": [
        [
          {
            "node": "Filter New Emails",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter New Emails": {
      "main": [
        [
          {
            "node": "Has New Emails?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has New Emails?": {
      "main": [
        [
          {
            "node": "Prepare Batches",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "All Duplicates",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Batches": {
      "main": [
        [
          {
            "node": "Build LLM Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build LLM Prompt": {
      "main": [
        [
          {
            "node": "Classify Batch LLM",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Classify Batch LLM": {
      "main": [
        [
          {
            "node": "Parse & Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse & Merge": {
      "main": [
        [
          {
            "node": "Collect All Classified",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Collect All Classified": {
      "main": [
        [
          {
            "node": "Batch Ingest",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Batch Ingest": {
      "main": [
        [
          {
            "node": "Prepare Mark Read",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Mark Read": {
      "main": [
        [
          {
            "node": "Gmail - Mark as Read",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "877a1ec097ce73a18eadfd6a602288208de9f708b0a5028e3ba258335298a171"
  }
}
